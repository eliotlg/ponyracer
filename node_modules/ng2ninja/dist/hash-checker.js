"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var hash_files_1 = __importDefault(require("hash-files"));
var utils_1 = require("./utils");
var logger_1 = __importDefault(require("./logger"));
function findSpecIfItExists(hashes, spec) {
    return hashes.find(function (hash) {
        return hash.name.indexOf(spec) !== -1;
    });
}
function listSpecs() {
    return utils_1.listFiles('./src/**/*.spec.ts');
}
function computeHash(specs) {
    return specs.map(function (name) {
        return { name: name, hash: hash_files_1.default.sync({ files: [name] }) };
    });
}
function computeHashesOfSpecs() {
    return listSpecs()
        .then(function (specs) { return computeHash(specs); });
}
var hashChecker = function (options) { return new Promise(function (resolve, reject) {
    logger_1.default.log('Checking submission...');
    utils_1.readFile('./exercise.json')
        .then(function (exerciseData) {
        var exercise = JSON.parse(exerciseData);
        logger_1.default.success('Pack V' + exercise.pack + ' - Exercise ' + exercise.id + ' - ' + exercise.title);
        if (options['skip-check']) {
            return resolve(exercise);
        }
        return exercise;
    }, function (error) {
        logger_1.default.error('Looks like you have no exercise.json file.');
        logger_1.default.debug(options, 'An error occurred while reading exercise.json: ', error);
        return Promise.reject();
    })
        // then compute the hash of every spec
        .then(function (exercise) { return Promise.all([exercise, computeHashesOfSpecs()]); })
        // then decide if the submission is correct or not
        .then(function (_a) {
        var exercise = _a[0], hashes = _a[1];
        logger_1.default.debug(options, 'Exercise :', exercise);
        logger_1.default.debug(options, 'Hashes :', hashes);
        var specsInError = [];
        var specsNotFound = [];
        exercise.specs.forEach(function (file) {
            var spec = findSpecIfItExists(hashes, file.name);
            if (spec) {
                if (spec.hash !== file.hash) {
                    specsInError.push(file.name);
                }
            }
            else {
                specsNotFound.push(file.name);
            }
        });
        if (specsInError.length !== 0 || specsNotFound.length !== 0) {
            if (specsInError.length !== 0) {
                logger_1.default.error('It looks like you forgot to update these spec files');
                logger_1.default.error('or that you modified them manually:');
                specsInError.forEach(function (spec) { return logger_1.default.error(' - ' + spec); });
            }
            if (specsNotFound.length !== 0) {
                logger_1.default.error('It looks like you forgot to add these spec files:');
                specsNotFound.forEach(function (spec) { return logger_1.default.error(' - ' + spec); });
            }
            logger_1.default.error('Copy the new specs and try again.');
            return Promise.reject();
        }
        return exercise;
    }, function (error) {
        logger_1.default.debug(options, 'Error while computing the hash of the spec files. ', error);
        return Promise.reject(error);
    })
        .then(function (exercise) { return resolve(exercise); }, function (error) { return reject(error); });
}); };
exports.default = hashChecker;
